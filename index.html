<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bricker</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #000;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }

        .together {
            width: fit-content;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            padding-top: 0;
            background: #e9dcaf;
        }

        canvas {
            display: flex;
            align-self: center;
            background: #f4eed6;
            border: 3px solid #444;
        }

        .info-container {
            color: #000;
            width: 150px;
        }

        .ui {
            position: relative;
            align-self: center;
            width: 950px;
            background: #e9dcaf;
            padding: 0;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            margin: 0;
        }

        .ui h1 {
            margin: 0;
            font-size: 20px;
            font-weight: 300;
            color: #000;
        }

        .level-count {
            margin: 5px 0;
            font-size: 18px;
            font-weight: 500;
        }

        .gold-count {
            margin: 5px 0;
            font-size: 25px;
            font-weight: 900;
        }

        .ui button {
            padding: 5px 10px;
            margin-top: 5px;
            background: #0074d9;
            border: none;
            color: white;
            border-radius: 5px;
            cursor: pointer;
        }

        .ui button:hover {
            background: #0053a6;
        }

        .ball-options {
            display: flex;
            justify-content: space-around;
            margin: 0;
            margin-bottom: 10px;
            background: #e9dcaf;
            padding: 0px;
            gap: 5px
        }

        .ball-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 60px;
            user-select: none;
            cursor: pointer;
        }

        .ball-option p {
            color: #444;
        }
        
        /*#weapons-btn {
            height: fit-content;
            padding: 15px;
            border: 1px solid #444;
            background: #f4eed6;
            color: #000;
            font-weight: 600;
            align-self: center;
            margin-left: 15px;
        }
        
        #weapons-btn:hover {
            opacity: 0.5;
        }*/
        
        #weapons-btn {
            width: fit-content;
            
            padding: 10px;
            border: 1px solid #444;
            background: #f4eed6;
            color: #000;
            font-weight: 600;
            align-self: end;
            margin-left: 0px;
        }
        
        #weapons-btn p {
            margin-top: 10px;
            margin-bottom: 12px;
        }
        
        #weapons-btn:hover {
            opacity: 0.5;
        }

        .ball-option:hover .ball-preview {
            opacity: 0.5;
        }

        .ball-preview {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f4eed6;
            border: 1px solid #444;
            border-radius: 50%;
            margin-bottom: 5px;
        }

        .ball-options canvas {
            border: 1px solid #444;
        }

        .ball-price {
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            border: 1px solid #444;
            width: 100%;
            color: #000;
            padding: 2px 0;
        }
    </style>
</head>

<body>
    <div class="together">

        <div class="ui">
            <div class="info-container">
                <p class="gold-count">Gold: <span id="gold">20</span></p>
                <p class="level-count">Level: <span id="level">1</span></p>
            </div>

            <div class="ball-options">
                <div class="ball-option" id="sniper-option" onclick="buyBall('sniper')">
                    <p>Sniper</p>
                    <div class="ball-preview">
                        <canvas id="sniper-preview" width="60" height="60"></canvas>
                    </div>
                    <div class="ball-price">
                        <span id="sniperPrice">20</span>
                    </div>
                </div>
                <div class="ball-option" id="big-option" onclick="buyBall('big')">
                    <p>Big</p>
                    <div class="ball-preview">
                        <canvas id="big-preview" width="60" height="60"></canvas>
                    </div>
                    <div class="ball-price">
                        <span id="bigPrice">30</span>
                    </div>
                </div>
                <div class="ball-option" id="explosion-option" onclick="buyBall('explosion')">
                    <p>Bomb</p>
                    <div class="ball-preview">
                        <canvas id="explosion-preview" width="60" height="60"></canvas>
                    </div>
                    <div class="ball-price">
                        <span id="explosionPrice">40</span>
                    </div>
                </div>
                <div class="ball-option" id="multiplying-option" onclick="buyBall('multiplying')">
                    <p>Clones</p>
                    <div class="ball-preview">
                        <canvas id="multiplying-preview" width="60" height="60"></canvas>
                    </div>
                    <div class="ball-price">
                        <span id="multiplyingPrice">50</span>
                    </div>
                </div>
                <div class="ball-option" id="auto-option" onclick="buyAutoBall()">
                    <p>Auto</p>
                    <div class="ball-preview">
                        <canvas id="auto-preview" width="60" height="60"></canvas>
                    </div>
                    <div class="ball-price">
                        <span id="multiplyingPrice">100</span>
                    </div>
                </div>
                <div class="ball-option" id="weapons-btn">
                    <p>Mass Destruction</p>
                    <div class="ball-price">
                        <span>1000</span>
                    </div>
                </div>
                
                <!--<button id="weapons-btn">Mass Destruction</button>-->
            </div>
            

            <h1>Bricker</h1>




            <!--<button onclick="buyBall('sniper')">Buy Sniper Ball (<span id="sniperCost">20</span> Gold)</button>
            <button onclick="buyBall('big')">Buy Big Ball (<span id="bigCost">30</span> Gold)</button>
            <button onclick="buyBall('explosion')">Buy Explosion Ball (<span id="explosionCost">40</span> Gold)</button>
            <button onclick="buyBall('multiplying')">Buy Multiplying Ball (<span id="multiplyingCost">50</span> Gold)</button>
            <button onclick="buyAutoBall()">Buy Auto Ball (100 Gold)</button>-->

        </div>
        <canvas id="gameCanvas" width="1000" height="520"></canvas>
    </div>

    <script>
        window.onload = function() {
            const audio = document.getElementById('backgroundMusic');
            audio.play(); // Ensure the audio plays as soon as the page is loaded
        };
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state variables
        let gold = 20;

        let idleGoldPerSecond = 1; // Gold earned per second passively

        function generatePassiveGold() {
            gold += idleGoldPerSecond;
            updateUI();
        }

        // Start generating passive gold every second
        setInterval(generatePassiveGold, 1000);

        let autoBallPrice = 100;

        let level = 1;
        let balls = [];
        let bricks = [];
        let powerUps = [];
        let autoBalls = [];
        const brickWidth = 70;
        const brickHeight = 30;

        const ballPrices = {
            sniper: 20,
            big: 30,
            explosion: 40,
            multiplying: 50
        };

        // UI elements
        const goldDisplay = document.getElementById('gold');
        const levelDisplay = document.getElementById('level');

        canvas.addEventListener('click', (e) => {
            const mouseX = e.clientX - canvas.offsetLeft;
            const mouseY = e.clientY - canvas.offsetTop;

            let isHovering = false;

            // Check if a brick was clicked
            bricks.forEach(brick => {
                if (
                    mouseX > brick.x && mouseX < brick.x + brick.width &&
                    mouseY > brick.y && mouseY < brick.y + brick.height
                ) {
                    brick.hit(); // Remove the brick
                }
            });


            canvas.style.cursor = isHovering ? 'pointer' : 'default';
        });


        // Ball class
        class Ball {
            constructor(x, y, radius, dx, dy, color, type) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.dx = dx;
                this.dy = dy;
                this.color = color;
                this.type = type;
                this.powerUpUsed = false;
                this.hasBouncedWall = false;
            }

            move() {
                this.x += this.dx;
                this.y += this.dy;

                // Bounce off walls
                if (this.x + this.radius > canvas.width || this.x - this.radius < 0) {
                    this.dx = -this.dx;
                    if (this.type === 'sniper') this.redirectToClosestBrick();
                }
                if (this.y + this.radius > canvas.height || this.y - this.radius < 0) {
                    this.dy = -this.dy;
                    if (this.type === 'sniper') this.redirectToClosestBrick();
                }

                // Check collisions with bricks
                bricks.forEach(brick => {
                    if (
                        this.x > brick.x &&
                        this.x < brick.x + brick.width &&
                        this.y > brick.y &&
                        this.y < brick.y + brick.height
                    ) {
                        this.handleBrickCollision(brick);
                    }
                });
            }

            redirectToClosestBrick() {
                if (this.type === 'sniper') {
                    const closestBrick = this.getClosestBrick();
                    if (closestBrick) {
                        const angle = Math.atan2(closestBrick.y + brickHeight / 2 - this.y, closestBrick.x + brickWidth / 2 - this.x);
                        this.dx = Math.cos(angle) * 5;
                        this.dy = Math.sin(angle) * 5;
                    }
                }
            }

            getClosestBrick() {
                let closestBrick = null;
                let closestDistance = Infinity;

                bricks.forEach(brick => {
                    const distance = Math.hypot(
                        this.x - (brick.x + brick.width / 2),
                        this.y - (brick.y + brick.height / 2)
                    );

                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestBrick = brick;
                    }
                });

                return closestBrick;
            }

            handleBrickCollision(brick) {
                brick.hit();
                this.dy = -this.dy;

                if (this.type === 'explosion') {
                    bricks.forEach(b => {
                        const distance = Math.hypot(b.x - brick.x, b.y - brick.y);
                        if (distance < 60) b.hit();
                    });
                } else if (this.type === 'multiplying') {
                    balls.push(new Ball(
                        this.x,
                        this.y,
                        this.radius / 2,
                        (Math.random() > 0.5 ? 1 : -1) * 4,
                        (Math.random() > 0.5 ? 1 : -1) * 4,
                        this.color,
                        'child'
                    ));
                } else if (this.type === 'child') {
                    // Remove the child ball after hitting a brick
                    balls = balls.filter(ball => ball !== this);
                }

            }

            draw() {
                drawTrail(this);
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();
            }
        }

        class Brick {
            constructor(x, y, health) {
                this.x = x;
                this.y = y;
                this.width = brickWidth;
                this.height = brickHeight;
                this.health = health;
                this.hover = false;
            }

            isCursorHovering(mouseX, mouseY) {
                return (
                    mouseX > this.x &&
                    mouseX < this.x + this.width &&
                    mouseY > this.y &&
                    mouseY < this.y + this.height
                );
            }

            hit() {
                this.health--;
                if (this.health <= 0) {
                    bricks = bricks.filter(brick => brick !== this);
                    gold += 5;
                    spawnPowerUp();
                    updateUI();
                }
            }

            draw() {
                ctx.fillStyle = `rgba(255, 0, 0, ${this.health / 3})`;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#fff';
                ctx.font = '18px Arial';
                ctx.fillText(this.health, this.x + this.width / 2 - 6, this.y + this.height / 2 + 4);

                ctx.strokeStyle = '#333'; // Dark grey border
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
            }

        }


        class BossBrick extends Brick {
            constructor(x, y) {
                super(x, y, 10); // Boss has 10 health
                this.width = 100;
                this.height = 40;
            }

            draw() {
                ctx.fillStyle = 'darkred';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#fff';
                ctx.font = '15px Arial';
                ctx.fillText(`Boss: ${this.health}`, this.x + this.width / 4, this.y + this.height / 2);
            }
        }


        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 20;
                this.height = 20;
                this.type = type;
                this.active = true;
                this.spawnTime = Date.now(); // Track when the power-up was created
            }

            draw() {
                if (!this.active) return; // Skip drawing if inactive
                ctx.fillStyle = {
                    gold: 'gold',
                    speed: 'cyan',
                    multiBall: 'magenta'
                }[this.type];
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }

            collect() {
                // Check if power-up has expired
                if (Date.now() - this.spawnTime > 20000) {
                    this.active = false;
                    return;
                }

                // Collect power-up if ball hasn't already used one
                balls.forEach(ball => {
                    if (ball.powerUpUsed) return;

                    if (
                        ball.x + ball.radius > this.x &&
                        ball.x - ball.radius < this.x + this.width &&
                        ball.y + ball.radius > this.y &&
                        ball.y - ball.radius < this.y + this.height
                    ) {
                        this.activatePowerUp(ball); // Activate power-up for the ball
                    }
                });
            }

            activatePowerUp(ball) {
                ball.powerUpUsed = true; // Mark that the ball has used a power-up

                if (this.type === 'gold') gold += 50;
                if (this.type === 'speed') {
                    ball.dx *= 1.5;
                    ball.dy *= 1.5;
                }
                if (this.type === 'multiBall') {
                    balls.push(new Ball(ball.x, ball.y, ball.radius, -ball.dx, -ball.dy, ball.color, ball.type));
                }

                this.active = false; // Deactivate power-up after being collected
                updateUI();
            }
        }

        class AutoBall {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height - 30; // Bottom of the canvas
                this.radius = 8;
                this.dy = -4; // Always moves upward
                this.color = 'black';
            }

            move() {
                this.y += this.dy;
                if (this.y < 0) {
                    this.y = canvas.height - 30; // Reset position
                    this.x = Math.random() * canvas.width; // Randomise horizontal position
                }

                // Check collisions with bricks
                bricks.forEach(brick => {
                    if (
                        this.x > brick.x &&
                        this.x < brick.x + brick.width &&
                        this.y > brick.y &&
                        this.y < brick.y + brick.height
                    ) {
                        brick.hit();
                        this.y = canvas.height - 30; // Reset position
                        this.x = Math.random() * canvas.width;
                    }
                });
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();
            }
        }



        /*function spawnPowerUp() {
            if (Math.random() < 0.05) {


                const type = ['gold', 'speed', 'multiBall'][Math.floor(Math.random() * 3)];
                const x = Math.random() * (canvas.width - 20);
                const y = Math.random() * (canvas.height - 20);
                powerUps.push(new PowerUp(x, y, type));
            }
        }*/

        function spawnPowerUp() {
            if (Math.random() < 0.05) { // Reduce chance to 10%
                let x, y, isOverlapping;

                // Ensure power-up does not overlap with bricks
                do {
                    x = Math.random() * (canvas.width - 20);
                    y = Math.random() * (canvas.height - 20);

                    isOverlapping = bricks.some(brick => {
                        return (
                            x < brick.x + brick.width &&
                            x + 20 > brick.x &&
                            y < brick.y + brick.height &&
                            y + 20 > brick.y
                        );
                    });
                } while (isOverlapping);

                const type = ['gold', 'speed', 'multiBall'][Math.floor(Math.random() * 3)];
                powerUps.push(new PowerUp(x, y, type));
            }
        }



        // Spawn a level of bricks
        /*function spawnBricks() {
            const rows = Math.min(level, Math.floor(canvas.height / brickHeight) - 1); // Limit rows to fit canvas
            const cols = Math.min(5, Math.floor(canvas.width / brickWidth)); // Limit columns to fit canvas
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 4; // Adjust to avoid overlap with balls

            bricks = []; // Clear any existing bricks
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = centerX - (cols * brickWidth) / 2 + col * brickWidth;
                    const y = centerY + row * brickHeight;
                    const health = level + Math.floor(level / 3); // Scaling health
                    bricks.push(new Brick(x, y, health));
                }
            }

            if (level % 5 === 0) {
                bricks.push(new BossBrick(canvas.width / 2 - 50, centerY - brickHeight * 2));
            }
        }*/

        function spawnBricks() {
            const maxRows = 11; // Maximum height (rows)
            const maxCols = 6; // Maximum width (columns)
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            if (bricks.length < maxRows * maxCols) {
                // Add bricks only if the limit hasn't been reached
                const rows = Math.min(level, maxRows);
                const cols = Math.min(5, maxCols); // Keep initial width at 5, max out at 6

                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const x = centerX - (cols * brickWidth) / 2 + col * brickWidth;
                        const y = centerY - (rows * brickHeight) / 2 + row * brickHeight;

                        const health = level + Math.floor(level / 3); // Scaling health
                        bricks.push(new Brick(x, y, health));
                    }
                }
            } else {
                // Only increase the health of existing bricks if the limit is reached
                bricks.forEach(brick => {
                    brick.health += Math.floor(level / 3);
                });
            }

            // Add a BossBrick at every 5th level, within constraints
            if (level % 5 === 0 && !bricks.some(b => b instanceof BossBrick)) {
                bricks.push(new BossBrick(canvas.width / 2 - 50, canvas.height / 4));
            }
        }



        function drawBallPreview(canvasId, color, radius) {
            const previewCanvas = document.getElementById(canvasId);
            const previewCtx = previewCanvas.getContext('2d');

            // Clear the canvas before redrawing
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

            // Draw the ball
            previewCtx.beginPath();
            previewCtx.arc(previewCanvas.width / 2, previewCanvas.height / 2, radius, 0, Math.PI * 2);
            previewCtx.fillStyle = color;
            previewCtx.fill();
            previewCtx.closePath();
        }

        // Update UI
        function updateUI() {
            goldDisplay.textContent = gold;
            levelDisplay.textContent = level;

            document.getElementById('sniperPrice').textContent = ballPrices.sniper;
            document.getElementById('bigPrice').textContent = ballPrices.big;
            document.getElementById('explosionPrice').textContent = ballPrices.explosion;
            document.getElementById('multiplyingPrice').textContent = ballPrices.multiplying;

            // Draw previews for each ball
            drawBallPreview('sniper-preview', 'blue', 8); // Sniper ball
            drawBallPreview('big-preview', 'green', 12); // Big ball
            drawBallPreview('explosion-preview', 'orange', 8); // Explosion ball
            drawBallPreview('multiplying-preview', 'purple', 8); // Multiplying ball
            drawBallPreview('auto-preview', 'black', 8); // Multiplying ball
        }
        // Buy a ball
        function buyBall(type) {
            if (gold >= ballPrices[type]) {
                gold -= ballPrices[type];
                ballPrices[type] += 10;

                const radius = type === 'big' ? 12 : 8;
                const speed = type === 'sniper' ? 5 : 3 + Math.random();
                const dx = speed * (Math.random() > 0.5 ? 1 : -1);
                const dy = speed * (Math.random() > 0.5 ? 1 : -1);
                const color = {
                    sniper: 'blue',
                    big: 'green',
                    explosion: 'orange',
                    multiplying: 'purple'
                }[type];
                balls.push(new Ball(canvas.width / 2, canvas.height / 2, radius, dx, dy, color, type));
                updateUI();
            } else {
                alert('Not enough gold!');
            }
        }

        function buyAutoBall() {
            if (gold >= 100) {
                gold -= 100;
                autoBalls.push(new AutoBall());
                autoBallPrice = Math.floor(autoBallPrice * 1.5);
                document.getElementById('multiplyingPrice').textContent = autoBallPrice;
                updateUI();
            } else {
                alert('Not enough gold!');
            }
        }

        function updateAutoBallPreview() {
            const canvas = document.getElementById('auto-preview');
            const context = canvas.getContext('2d');

            // Clear the canvas for redrawing
            context.clearRect(0, 0, canvas.width, canvas.height);

            // Draw the auto-ball (example: a red ball)
            context.fillStyle = 'black';
            context.beginPath();
            context.arc(canvas.width / 2, canvas.height / 2, canvas.width / 2 - 5, 0, Math.PI * 2);
            context.fill();
        }

        function upgradePassiveGold() {
            if (gold >= 50) {
                gold -= 50;
                idleGoldPerSecond += 1; // Increase passive gold rate
                updateUI();
            } else {
                alert('Not enough gold!');
            }
        }



        // Weapon cost
        const weaponCost = 1000;

        // Add event listener to the weapons button
        document.getElementById('weapons-btn').addEventListener('click', () => {
            if (gold >= weaponCost) {
                gold -= weaponCost; // Deduct the cost
                deployRandomWeapon(); // Deploy a random weapon
                updateUI(); // Update UI with new gold count
            } else {
                alert('Not enough gold!');
            }
        });

        // Randomly deploy a weapon
        function deployRandomWeapon() {
            const weapons = ['nuke', 'airstrike', 'gravity', 'laser', 'blackhole'];
            const randomWeapon = weapons[Math.floor(Math.random() * weapons.length)];
            switch (randomWeapon) {
                case 'nuke':
                    deployNuke();
                    break;
                case 'airstrike':
                    deployAirstrike();
                    break;
                case 'gravity':
                    manipulateGravity();
                    break;
                case 'laser':
                    deployLaser();
                    break;
                case 'blackhole':
                    createBlackhole();
                    break;
            }
        }

        // Nuke - Clears all bricks for 10 seconds
        function deployNuke() {
            alert('Nuke deployed! All bricks will be destroyed for the next 10 seconds!');
            const explosionRadius = 200; // Explosion radius for the nuke

            // Draw Nuke Explosion
            setTimeout(() => {
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height / 2, explosionRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; // Semi-transparent red for the explosion effect
                ctx.fill();
                ctx.closePath();

                // Destroy all bricks
                bricks.forEach(brick => brick.hit());

                spawnPowerUp(); // Optionally spawn power-ups after nuke
            }, 0); // Nuke effect occurs immediately

            // Restore after 10 seconds
            setTimeout(() => {
                // Additional effects like fading away could go here
            }, 10000); // Nuke effect lasts for 10 seconds
        }

        // Airstrike - Randomly targets 3 bricks and destroys them
        function deployAirstrike() {
            alert('Airstrike deployed! 3 random bricks will be destroyed!');
            const airstrikeEffectDuration = 500; // Duration of airstrike effect in milliseconds
            const airstrikeArea = 300; // Airstrike area width

            // Draw Airstrike area
            ctx.fillStyle = 'rgba(0, 0, 255, 0.3)'; // Blue with transparency for airstrike
            ctx.fillRect(canvas.width / 2 - airstrikeArea / 2, 0, airstrikeArea, 50); // Airstrike path

            // Target 3 random bricks
            for (let i = 0; i < 3; i++) {
                const randomBrick = bricks[Math.floor(Math.random() * bricks.length)];
                if (randomBrick) {
                    randomBrick.hit(); // Destroy brick if hit by airstrike
                }
            }

            // Stop Airstrike effect after a small delay
            setTimeout(() => {
                // Fade out effect or other visual feedback could go here
            }, airstrikeEffectDuration);
        }

        // Gravity Manipulation - Increases gravity, making balls fall faster for 10 seconds
        function manipulateGravity() {
            alert('Gravity increased! Balls will fall faster for the next 10 seconds!');
            const originalDy = balls.map(ball => ball.dy);

            // Visual effect for gravity manipulation
            const gravityEffectRadius = 150;
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, gravityEffectRadius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0, 255, 255, 0.3)'; // Cyan for gravity effect
            ctx.fill();
            ctx.closePath();

            // Increase gravity on balls
            balls.forEach(ball => {
                ball.dy *= 1.5; // Increase gravity effect
            });

            // Reset gravity after 10 seconds
            setTimeout(() => {
                balls.forEach((ball, index) => {
                    ball.dy = originalDy[index]; // Restore original gravity
                });
            }, 10000); // Gravity effect lasts for 10 seconds
        }

        // Laser - Fires a laser that destroys any brick it touches for 5 seconds
        function deployLaser() {
            alert('Laser deployed! Any brick it touches will be destroyed for the next 5 seconds!');
            const laser = {
                x: canvas.width / 2,
                y: 0,
                width: 5,
                height: canvas.height,
                color: 'red'
            };

            // Visual effect: Laser continuously drawn for 5 seconds
            const laserInterval = setInterval(() => {
                ctx.fillStyle = laser.color;
                ctx.fillRect(laser.x, laser.y, laser.width, laser.height); // Laser beam drawn from top to bottom

                // Check for collisions with bricks
                bricks.forEach(brick => {
                    if (laser.x + laser.width > brick.x && laser.x < brick.x + brick.width) {
                        brick.hit(); // Destroy brick if hit by laser
                    }
                });
            }, 50); // Fire laser every 50ms

            // Stop laser after 5 seconds
            setTimeout(() => {
                clearInterval(laserInterval);
            }, 5000); // Laser lasts for 5 seconds
        }

        // Blackhole - Creates a blackhole that pulls all balls and bricks towards it for 5 seconds
        function createBlackhole() {
            alert('Blackhole created! All balls and bricks are pulled towards it for the next 5 seconds!');
            const blackhole = {
                x: canvas.width / 2,
                y: canvas.height / 2,
                radius: 50
            };

            // Visual effect: Blackhole in the center with true black color
            const blackholeInterval = setInterval(() => {
                ctx.beginPath();
                ctx.arc(blackhole.x, blackhole.y, blackhole.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 1)'; // Black with no transparency
                ctx.fill();
                ctx.closePath();

                // Pull all balls and bricks towards the blackhole
                balls.forEach(ball => {
                    const angle = Math.atan2(blackhole.y - ball.y, blackhole.x - ball.x);
                    ball.x += Math.cos(angle) * 2; // Move balls towards blackhole
                    ball.y += Math.sin(angle) * 2;
                });

                bricks.forEach((brick, index) => {
                    const angle = Math.atan2(blackhole.y - brick.y, blackhole.x - brick.x);
                    brick.x += Math.cos(angle) * 0.5; // Move bricks towards blackhole
                    brick.y += Math.sin(angle) * 0.5;

                    // If a brick gets too close to the black hole, destroy it
                    const distance = Math.sqrt(Math.pow(blackhole.x - brick.x, 2) + Math.pow(blackhole.y - brick.y, 2));
                    if (distance < blackhole.radius) {
                        brick.hit(); // Destroy the brick if it reaches the black hole
                    }
                });
            }, 30); // Update every 30ms

            // Stop blackhole effect after 5 seconds
            setTimeout(() => {
                clearInterval(blackholeInterval);
            }, 5000);
        }





        /*function drawTrail(ball) {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius * 1.2, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 255, 0.2)`;
            ctx.fill();
            ctx.closePath();
        }*/

        function drawTrail(ball) {
            const speed = Math.sqrt(ball.dx ** 2 + ball.dy ** 2);
            const trailLength = Math.max(5, speed * 3); // Adjust trail length based on speed

            // Store trail positions
            if (!ball.trail) ball.trail = [];
            ball.trail.push({
                x: ball.x,
                y: ball.y
            });

            // Limit the trail to the calculated length
            if (ball.trail.length > trailLength) {
                ball.trail.shift();
            }

            // Draw the trail fading from older to newer positions
            ball.trail.forEach((position, index) => {
                const alpha = index / ball.trail.length; // Gradual fade effect

                ctx.beginPath();
                ctx.arc(position.x, position.y, ball.radius * 1.2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${0.2 * alpha})`;
                ctx.fill();
                ctx.closePath();
            });
        }



        // Start next level
        function nextLevel() {
            if (bricks.length === 0) {
                level++;
                spawnBricks();
                updateUI();
            }
        }

        function gameLoop() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw and move balls
            balls.forEach(ball => {
                drawTrail(ball);
                ball.move();
                ball.draw();
            });

            // Check for power-up collisions
            powerUps.forEach(powerUp => {
                if (powerUp.active) {
                    powerUp.draw();

                    // Check collision with balls
                    balls.forEach(ball => {
                        if (
                            ball.x + ball.radius > powerUp.x &&
                            ball.x - ball.radius < powerUp.x + powerUp.width &&
                            ball.y + ball.radius > powerUp.y &&
                            ball.y - ball.radius < powerUp.y + powerUp.height
                        ) {
                            powerUp.collect(); // Collect power-up
                        }
                    });
                }
            });

            // Draw and move auto balls
            autoBalls.forEach(autoBall => {
                autoBall.move();
                autoBall.draw();
            });


            // Draw bricks
            bricks.forEach(brick => brick.draw());

            // Check for next level
            nextLevel();

            // Request next frame
            requestAnimationFrame(gameLoop);
        }


        // Start the game
        spawnBricks();
        gameLoop();
    </script>
</body>

</html>

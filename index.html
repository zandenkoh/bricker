<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bricker</title>
    <link rel="icon" type="image/x-icon" href="https://cdn-icons-png.flaticon.com/512/104/104031.png">
    <link href="https://unpkg.com/intro.js@7.0.1/introjs.min.css" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #000;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }

        .together {
            width: fit-content;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            padding-top: 0;
            background: #e9dcaf;
        }

        canvas {
            display: flex;
            align-self: center;
            background: #f4eed6;
            border: 3px solid #444;
        }

        .info-container {
            color: #000;
            width: 150px;
        }

        .ui {
            position: relative;
            align-self: center;
            width: 950px;
            background: #e9dcaf;
            padding: 0;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            margin: 0;
        }

        .ui h1 {
            margin: 0;
            font-size: 20px;
            font-weight: 300;
            color: #000;
        }

        .level-count {
            margin: 5px 0;
            font-size: 18px;
            font-weight: 500;
        }

        .gold-count {
            margin: 5px 0;
            font-size: 25px;
            font-weight: 900;
        }

        .ui button {
            padding: 5px 10px;
            margin-top: 5px;
            background: #000;
            border: none;
            color: white;
            border-radius: 5px;
            cursor: pointer;
        }

        .ui button:hover {
            background: #0053a6;
        }

        .ball-options {
            display: flex;
            justify-content: space-around;
            margin: 0;
            margin-bottom: 10px;
            background: #e9dcaf;
            padding: 0px;
            gap: 5px
        }

        .ball-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 60px;
            user-select: none;
            cursor: pointer;
        }

        .ball-option p {
            color: #444;
        }

        #weapons-btn {
            width: fit-content;
            padding: 10px;
            border: 1px solid #444;
            background: #f4eed6;
            color: #000;
            font-weight: 600;
            align-self: end;
            margin-left: 0px;
        }

        #weapons-btn p {
            margin-top: 10px;
            margin-bottom: 12px;
        }

        #weapons-btn:hover {
            opacity: 0.5;
        }

        .ball-option:hover .ball-preview {
            opacity: 0.5;
        }

        .ball-preview {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f4eed6;
            border: 1px solid #444;
            border-radius: 50%;
            margin-bottom: 5px;
        }

        .ball-options canvas {
            border: 1px solid #444;
        }

        .ball-price {
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            border: 1px solid #444;
            width: 100%;
            color: #000;
            padding: 2px 0;
        }

        #save-button {
            padding: 5px 10px;
            margin-top: 5px;
            background: #000;
            border: none;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        #save-button:hover {
            background: transparent;
            color: #000;
            outline: 1px solid #000;
        }

        #save-button:active {
            transform: scale(0.95);
        }

        .login-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .login-popup {
            background: #e9dcaf;
            padding: 20px;
            border: 3px solid #444;
            border-radius: 10px;
            width: 300px;
            text-align: center;
            color: #000;
        }

        .login-popup h2 {
            margin: 0 0 15px;
            font-size: 20px;
            font-weight: 600;
        }

        .login-popup input {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #444;
            border-radius: 5px;
            background: #f4eed6;
            color: #000;
            box-sizing: border-box;
        }

        .login-popup button {
            padding: 8px 15px;
            margin: 10px 5px;
            background: #000;
            border: none;
            color: white;
            border-radius: 5px;
            cursor: pointer;
        }

        .login-popup button:hover {
            background: #0053a6;
        }

        .login-popup p {
            margin: 10px 0;
            font-size: 14px;
            color: #444;
        }

        .button-group {
            display: flex;
            flex-direction: row;
            gap: 8px;
        }

        .inside-button-group {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            gap: 8px;
        }

        #my-balls-btn,
        #settings-btn {
            width: 100px;
            padding: 10px;
            border: 1px solid #444;
            background: #f4eed6;
            color: #000;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            border-radius: 0px;
            transition: transform 0s ease, box-shadow 0.2s ease, background 0s ease;
        }

        #my-balls-btn:hover,
        #settings-btn:hover {
            background: linear-gradient(145deg, #e9dcaf, #f4eed6);
        }

        #my-balls-btn p,
        #settings-btn p {
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .my-balls-popup,
        .settings-popup {
            background: #e9dcaf;
            padding: 20px;
            border: 3px solid #444;
            width: 450px;
            max-width: 90vw;
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
            color: #000;
        }

        .my-balls-popup::-webkit-scrollbar,
        .settings-popup::-webkit-scrollbar {
            width: 0;
        }

        .my-balls-popup h2,
        .settings-popup h2 {
            margin: 0 0 15px;
            font-size: 20px;
            font-weight: 600;
            text-transform: uppercase;
            color: #000;
            text-align: center;
        }

        .nav-tabs {
            display: flex;
            justify-content: center;
            gap: 5px;
            background: transparent;
            padding: 10px;
            margin-bottom: 15px;
            border: 0px solid #444;
        }

        .nav-tabs button {
            background: #f4eed6;
            border: 1px solid #444;
            color: #000;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            padding: 8px 15px;
            transition: background 0.2s ease, color 0.2s ease;
        }

        .nav-tabs button:hover {
            background: #e9dcaf;
            color: #000;
        }

        .nav-tabs button.active {
            background: #000;
            color: white;
            border: 1px solid #444;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .ball-stats,
        .upgrades-list,
        .rebirth-info {
            text-align: left;
            background: #f4eed6;
            padding: 12px;
            border: 2px solid #444;
        }

        .ball-stats div,
        .upgrades-list div {
            margin: 8px 0;
            padding: 10px;
            background: #e9dcaf;
            border: 0 solid #444;
            font-size: 14px;
            font-weight: 500;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ball-stats div canvas {
            border: 1px solid #000;
        }

        .upgrade-btn {
            padding: 8px 12px;
            background: #000;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            width: 140px;
        }
        .rebirth-btn {
            padding: 8px 12px;
            background: #000;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            width: fit-content;
        }

        .upgrade-btn:hover,
        .rebirth-btn:hover {
            background: transparent;
            color: #000;
            outline: 1px solid #000;
        }

        .settings-info {
            text-align: left;
            padding: 12px;
            background: #f4eed6;
            border: 2px solid #444;
        }

        .settings-info p {
            margin: 8px 0;
            font-size: 14px;
            font-weight: 500;
        }

        .settings-info input {
            width: 100%;
            padding: 6px;
            margin: 6px 0;
            border: 1px solid #444;
            background: #e9dcaf;
            color: #000;
            font-size: 14px;
        }

        .edit-icon {
            cursor: pointer;
            margin-left: 6px;
            font-size: 14px;
            transition: transform 0.2s ease;
        }

        .edit-icon:hover {
            transform: scale(1.1);
        }

        .upgrade-btn:hover {
            transform: scale(1);
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: transparent;
            color: #000;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.2s ease;
            border: none;
        }

        .close-btn svg {
            color: #000;
            fill: #000;
            width: 20px;
            height: 20px;
        }

        .close-btn:hover {
            background: #e9dcaf;
        }

        .custom-tooltip {
            background: #e9dcaf;
            border: 2px solid #444;
            color: #000;
            font-family: Arial, sans-serif;
            font-size: 14px;
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
        }

        .custom-highlight {
            border: 2px solid #0053a6;
            border-radius: 5px;
            background: rgba(0, 83, 166, 0.2);
        }

        .introjs-button {
            background: #000;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
        }

        .introjs-button:hover {
            background: #0053a6;
        }

        .introjs-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
    </style>
</head>

<body>
    <div class="together">
        <!-- Replace the existing .ui div in the HTML body with this updated version -->
        <div class="ui">
            <div class="info-container">
                <p class="gold-count">Gold: <span id="gold">20</span></p>
                <p class="level-count">Level: <span id="level">1</span></p>
                <button id="save-button">Save progress</button>
            </div>

            <div class="ball-options">
                <div class="ball-option" id="sniper-option" onclick="buyBall('sniper')">
                    <p>Sniper</p>
                    <div class="ball-preview">
                        <canvas id="sniper-preview" width="60" height="60"></canvas>
                    </div>
                    <div class="ball-price">
                        <span id="sniperPrice">20</span>
                    </div>
                </div>
                <div class="ball-option" id="big-option" onclick="buyBall('big')">
                    <p>Big</p>
                    <div class="ball-preview">
                        <canvas id="big-preview" width="60" height="60"></canvas>
                    </div>
                    <div class="ball-price">
                        <span id="bigPrice">30</span>
                    </div>
                </div>
                <div class="ball-option" id="explosion-option" onclick="buyBall('explosion')">
                    <p>Bomb</p>
                    <div class="ball-preview">
                        <canvas id="explosion-preview" width="60" height="60"></canvas>
                    </div>
                    <div class="ball-price">
                        <span id="explosionPrice">40</span>
                    </div>
                </div>
                <div class="ball-option" id="multiplying-option" onclick="buyBall('multiplying')">
                    <p>Clones</p>
                    <div class="ball-preview">
                        <canvas id="multiplying-preview" width="60" height="60"></canvas>
                    </div>
                    <div class="ball-price">
                        <span id="multiplyingPrice">50</span>
                    </div>
                </div>
                <div class="ball-option" id="auto-option" onclick="buyAutoBall()">
                    <p>Auto</p>
                    <div class="ball-preview">
                        <canvas id="auto-preview" width="60" height="60"></canvas>
                    </div>
                    <div class="ball-price">
                        <span id="autoPrice">100</span>
                    </div>
                </div>
                <div class="button-group">
                    <div class="ball-option" id="weapons-btn">
                        <p>Mass Destruction</p>
                        <div class="ball-price">
                            <span>1000</span>
                        </div>
                    </div>
                    <div class="inside-button-group">
                        <div class="ball-option" id="my-balls-btn">
                            <p>Upgrades</p>
                        </div>
                        <div class="ball-option" id="settings-btn">
                            <p>Settings</p>
                        </div>
                    </div>
                </div>
            </div>

            <h1>Bricker</h1>
        </div>
        <canvas id="gameCanvas" width="1000" height="520"></canvas>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <script src="https://unpkg.com/intro.js@7.0.1/intro.min.js"></script>

    <script>
        // Inject tooltip and toast styles
        const style = document.createElement('style');
        style.innerHTML = `
    .tooltip {
        position: absolute;
        background: #f4eed6;
        border: 1px solid #444;
        color: #000;
        padding: 5px 10px;
        border-radius: 5px;
        font-size: 12px;
        font-family: Arial, sans-serif;
        z-index: 10;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s;
        white-space: nowrap;
    }
    .ball-option:hover .tooltip {
        opacity: 1;
    }
    .toast {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: #e9dcaf;
        border: 1px solid #444;
        color: #000;
        padding: 10px 20px;
        border-radius: 5px;
        font-family: Arial, sans-serif;
        font-size: 14px;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.5s;
    }
    .toast.show {
        opacity: 1;
    }
    .upgrade-btn.disabled, .rebirth-btn.disabled {
        background: #ccc;
        cursor: not-allowed;
    }
`;
        document.head.appendChild(style);

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCusXta6VD-G0zanUUPPMhs4Qc9aThb33Q",
            authDomain: "bricker-by-zlabs.firebaseapp.com",
            projectId: "bricker-by-zlabs",
            storageBucket: "bricker-by-zlabs.firebasestorage.app",
            messagingSenderId: "949608388167",
            appId: "1:949608388167:web:beff34c82661cf69980362"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const database = firebase.database();

        function startTutorialIfNeeded(userId) {
            const tutorialCompleted = localStorage.getItem(`tutorialCompleted_${userId}`);
            if (!tutorialCompleted && document.querySelector('#gameCanvas')) {
                setTimeout(() => startTutorial(), 500); // Delay to ensure DOM is ready
            }
        }

        // Define Intro.js tutorial
        function startTutorial() {
            introJs().setOptions({
                steps: [{
                        intro: "Welcome to Bricker! Let's explore the game.",
                        position: "center"
                    },
                    {
                        element: document.querySelector('#gameCanvas'),
                        intro: "This is the game canvas where balls bounce to destroy bricks. Click bricks to reduce their health!",
                        position: "top"
                    },
                    {
                        element: document.querySelector('.info-container'),
                        intro: "Track your Gold and Level here. Gold buys balls and upgrades.",
                        position: "right"
                    },
                    {
                        element: document.querySelector('#save-button'),
                        intro: "Click here to save your progress to your account.",
                        position: "right"
                    },
                    {
                        element: document.querySelector('.ball-options'),
                        intro: "Buy different balls here, like Sniper or Bomb, each with unique abilities.",
                        position: "bottom"
                    },
                    {
                        element: document.querySelector('#my-balls-btn'),
                        intro: "View your balls, upgrade them, or check the leaderboard.",
                        position: "left"
                    },
                    {
                        element: document.querySelector('#settings-btn'),
                        intro: "Update your username or log out in the settings.",
                        position: "left"
                    },
                    {
                        element: document.querySelector('#weapons-btn'),
                        intro: "Use powerful weapons like Nuke or Blackhole for 1000 gold.",
                        position: "left"
                    },
                    {
                        intro: "You're all set! Start destroying bricks and earning gold!",
                        position: "center"
                    }
                ],
                showProgress: true,
                showBullets: false,
                exitOnOverlayClick: false,
                disableInteraction: true,
                tooltipClass: 'custom-tooltip',
                highlightClass: 'custom-highlight',
                nextLabel: 'Next',
                prevLabel: 'Back',
                doneLabel: 'Done'
            }).oncomplete(() => {
                const user = auth.currentUser;
                if (user) {
                    localStorage.setItem(`tutorialCompleted_${user.uid}`, 'true');
                }
            }).onexit(() => {
                const user = auth.currentUser;
                if (user) {
                    localStorage.setItem(`tutorialCompleted_${user.uid}`, 'true');
                }
            }).onbeforechange(() => {
                // Ensure elements are in view
                const element = introJs()._currentStep > 0 ? introJs()._introItems[introJs()._currentStep].element : null;
                if (element) element.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center'
                });
            }).start();
        }

        // Game state variables
        let gold = 20;
        let idleGoldPerSecond = 0.5;
        let autoBallPrice = 200;
        let level = 1;
        let balls = [];
        let bricks = [];
        let powerUps = [];
        let autoBalls = [];
        let effects = [];
        let rebirthCount = 0;
        const brickWidth = 70;
        const brickHeight = 30;
        const maxBalls = 1000;
        const maxPowerUps = 10;
        const maxBricks = 66;
        const ballPrices = {
            sniper: 50,
            big: 75,
            explosion: 100,
            multiplying: 125
        };
        let ballUpgrades = {
            sniper: {
                level: 1,
                speed: 4.5,
                damage: 1
            },
            big: {
                level: 1,
                speed: 2.7,
                damage: 1
            },
            explosion: {
                level: 1,
                speed: 2.7,
                damage: 2
            },
            multiplying: {
                level: 1,
                speed: 2.7,
                damage: 1
            },
            child: {
                level: 1,
                speed: 3.6,
                damage: 1
            }
        };
        let globalUpgrades = {
            speedBoost: {
                active: false,
                activationTime: null,
                cost: 200
            },
            goldBoost: {
                active: false,
                activationTime: null,
                cost: 150
            }
        };
        let stats = {
            totalPlayTime: 0,
            totalBallsPurchased: 0,
            totalUpgrades: 0,
            startTime: Date.now()
        };
        let username = '';
        let lastUpdateTime = Date.now();

        function getUpgradeCost(type) {
            return Math.floor(100 * Math.pow(1.3, ballUpgrades[type].level - 1));
        }

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // UI elements
        const goldDisplay = document.getElementById('gold');
        const levelDisplay = document.getElementById('level');
        const saveButton = document.getElementById('save-button');

        // Authentication state
        let isGuest = false;

        // Add tooltips to ball options
        const ballTooltips = {
            'sniper-option': 'Sniper Ball: Redirects to nearest brick on wall hit. Speed: 4.5, Damage: 1',
            'big-option': 'Big Ball: Larger size for more hitting surface. Speed: 2.7, Damage: 1',
            'explosion-option': 'Bomb Ball: Deals 2 damage to hit brick, 1 to nearby bricks. Speed: 2.7',
            'multiplying-option': 'Clones Ball: Spawns a small clone on brick hit. Speed: 2.7, Damage: 1',
            'auto-option': 'Auto Ball: Spawns at bottom, moves up, respawns if no brick hit. Speed: 3.6'
        };
        Object.keys(ballTooltips).forEach(id => {
            const element = document.getElementById(id);
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            tooltip.textContent = ballTooltips[id];
            element.appendChild(tooltip);
            element.addEventListener('mousemove', (e) => {
                tooltip.style.left = `${e.clientX - canvas.offsetLeft - 40}px`;
                tooltip.style.top = `${e.clientY - canvas.offsetTop + 170}px`;
            });
        });

        // Toast notification
        function showToast(message) {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.classList.add('show'), 100);
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 500);
            }, 2000);
        }

        // Show login popup on page load if not authenticated
        window.onload = function() {
            auth.onAuthStateChanged(user => {
                if (user && !isGuest) {
                    loadGameState(user.uid);
                } else {
                    showLoginPopup();
                }
            });
        };

        // Login popup
        function showLoginPopup() {
            const overlay = document.createElement('div');
            overlay.className = 'login-overlay';
            overlay.innerHTML = `
        <div class="login-popup">
            <h2>Login to Save Progress</h2>
            <input type="email" id="email" placeholder="Email">
            <input type="password" id="password" placeholder="Password">
            <div class="button-group">
                <button id="login-btn">Login</button>
                <button id="guest-btn">Play as Guest</button>
            </div>
            <p>Don't have an account? <a href="#" id="signup-link">Sign up</a></p>
        </div>
    `;
            document.body.appendChild(overlay);
            saveToLocalStorage(); // Save progress to local storage
            const loginBtn = overlay.querySelector('#login-btn');
            const guestBtn = overlay.querySelector('#guest-btn');
            const signupLink = overlay.querySelector('#signup-link');

            loginBtn.addEventListener('click', () => {
                loginBtn.disabled = true;
                login();
            });
            guestBtn.addEventListener('click', () => {
                guestBtn.disabled = true;
                playAsGuest();
            });
            signupLink.addEventListener('click', (e) => {
                e.preventDefault();
                showSignUpPopup(overlay);
            });
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    overlay.remove();
                    playAsGuest();
                }
            });
        }

        function showSignUpPopup(overlay) {
            overlay.innerHTML = `
        <div class="login-popup">
            <h2>Sign Up</h2>
            <input type="email" id="email" placeholder="Email">
            <input type="password" id="password" placeholder="Password">
            <input type="password" id="confirm-password" placeholder="Confirm Password">
            <div class="button-group">
                <button id="signup-btn">Sign Up</button>
                <button id="back-btn">Back to Login</button>
            </div>
        </div>
    `;
            const signupBtn = overlay.querySelector('#signup-btn');
            const backBtn = overlay.querySelector('#back-btn');
            signupBtn.addEventListener('click', () => {
                signupBtn.disabled = true;
                signUp();
            });
            backBtn.addEventListener('click', () => {
                showLoginPopup();
            });
        }

        // Login function
        function login() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            const loginBtn = document.querySelector('#login-btn');
            loginBtn.disabled = true;
            auth.signInWithEmailAndPassword(email, password)
                .then(userCredential => {
                    isGuest = false;
                    document.querySelector('.login-overlay').remove();
                    saveGameStateFromLocalStorage(userCredential.user.uid);
                    startTutorialIfNeeded(userCredential.user.uid);
                })
                .catch(error => {
                    showToast('Login failed: ' + error.message);
                    loginBtn.disabled = false;
                });
        }

        // Update signUp function
        function signUp() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            const confirmPassword = document.getElementById('confirm-password')?.value;
            const signupBtn = document.querySelector('#signup-btn');
            if (password !== confirmPassword) {
                showToast('Passwords do not match!');
                signupBtn.disabled = false;
                return;
            }
            signupBtn.disabled = true;
            auth.createUserWithEmailAndPassword(email, password)
                .then(userCredential => {
                    isGuest = false;
                    document.querySelector('.login-overlay').remove();
                    saveGameStateFromLocalStorage(userCredential.user.uid);
                    startTutorialIfNeeded(userCredential.user.uid);
                })
                .catch(error => {
                    showToast('Sign up failed: ' + error.message);
                    signupBtn.disabled = false;
                });
        }

        window.onload = function() {
            auth.onAuthStateChanged(user => {
                if (user && !isGuest) {
                    loadGameState(user.uid);
                    startTutorialIfNeeded(user.uid);
                } else {
                    showLoginPopup();
                }
            });
        };

        // Play as guest
        function playAsGuest() {
            isGuest = true;
            document.querySelector('.login-overlay').remove();
            startGame();
        }

        // Save game state
        function saveGameState() {
            if (isGuest) {
                showLoginPopupForSave();
                return;
            }
            const saveBtn = document.getElementById('save-button');
            saveBtn.disabled = true;
            const user = auth.currentUser;
            if (user) {
                const ballCounts = {
                    sniper: balls.filter(b => b.type === 'sniper').length,
                    big: balls.filter(b => b.type === 'big').length,
                    explosion: balls.filter(b => b.type === 'explosion').length,
                    multiplying: balls.filter(b => b.type === 'multiplying').length,
                    child: balls.filter(b => b.type === 'child').length
                };
                const gameState = {
                    gold,
                    level,
                    ballCounts,
                    autoBalls: autoBalls.length,
                    ballPrices,
                    autoBallPrice,
                    idleGoldPerSecond,
                    ballUpgrades,
                    stats,
                    username,
                    rebirthCount,
                    globalUpgrades: {
                        speedBoost: {
                            active: globalUpgrades.speedBoost.active,
                            activationTime: globalUpgrades.speedBoost.active ? Date.now() : null
                        },
                        goldBoost: {
                            active: globalUpgrades.goldBoost.active,
                            activationTime: globalUpgrades.goldBoost.active ? Date.now() : null
                        }
                    }
                };
                database.ref('leaderboard/' + user.uid).set({
                    rebirthCount: rebirthCount,
                    gold: gold,
                    username: username || 'Anonymous'
                });
                database.ref('users/' + user.uid + '/gameState').set(gameState)
                    .then(() => {
                        showToast('Progress saved successfully!');
                        saveBtn.disabled = false;
                    })
                    .catch(error => {
                        showToast('Save failed: ' + error.message);
                        saveBtn.disabled = false;
                    });
            }
        }

        function saveGameStateFromLocalStorage(uid) {
            const gameState = JSON.parse(localStorage.getItem('brickerGameState'));
            if (gameState) {
                database.ref('users/' + uid + '/gameState').set(gameState)
                    .then(() => {
                        localStorage.removeItem('brickerGameState');
                        showToast('Progress saved successfully!');
                        location.reload();
                    })
                    .catch(error => showToast('Save failed: ' + error.message));
            } else {
                loadGameState(uid);
            }
        }

        // Inject styles for leaderboard cards and user details popup
        const leaderboardStyle = document.createElement('style');
        leaderboardStyle.innerHTML = `
.leaderboard-list {
    max-height: 300px;
    overflow-y: auto;
    padding: 10px;
}

.leaderboard-card {
    display: flex;
    align-items: center;
    gap: 10px;
    background: linear-gradient(145deg, #f4eed6, #e9dcaf);
    border: 1px solid #444;
    border-radius: 8px;
    padding: 10px;
    margin-bottom: 10px;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
}

.leaderboard-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.leaderboard-card.current-user {
    background: #000;
    color: #fff;
    border: 1px solid #fff;
}

.leaderboard-card.current-user .info {
    color: #fff;
}

.leaderboard-card .rank {
    font-size: 16px;
    font-weight: bold;
    color: #333;
    width: 30px;
    height: 30px;
    line-height: 30px;
    text-align: center;
    border-radius: 50%;
    background: #ccc;
}

.leaderboard-card.rank-1 .rank {
    background: #ffd700;
}

.leaderboard-card.rank-2 .rank {
    background: #c0c0c0;
}

.leaderboard-card.rank-3 .rank {
    background: #cd7f32;
}

.leaderboard-card.current-user .rank {
    background: #fff;
    color: #000;
}

.leaderboard-card .info {
    flex: 1;
    font-size: 14px;
    color: #000;
}

.user-details-popup {
    background: #f4eed6;
    border: 1px solid #444;
    border-radius: 8px;
    padding: 15px;
    max-width: 300px;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1001;
    font-family: Arial, sans-serif;
}

.user-details-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    z-index: 1000;
}

.user-details-popup .close-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    background: none;
    border: none;
    cursor: pointer;
    padding: 5px;
}

.user-details-popup h3 {
    margin: 0 0 10px;
    color: #333;
}

.user-details-popup p {
    margin: 5px 0;
    font-size: 14px;
    color: #000;
}
`;
        document.head.appendChild(leaderboardStyle);

        function fetchLeaderboard() {
            console.log('Fetching leaderboard from users/...');
            const leaderboardList = document.querySelector('#leaderboard .leaderboard-list');
            if (!leaderboardList) {
                console.error('Leaderboard list element not found');
                return;
            }
            leaderboardList.innerHTML = '<p>Loading...</p>';
            database.ref('users').once('value')
                .then(snapshot => {
                    console.log('Users snapshot:', snapshot.val());
                    const leaders = [];
                    snapshot.forEach(child => {
                        const gameState = child.val().gameState;
                        if (gameState) {
                            leaders.push({
                                uid: child.key,
                                username: gameState.username || 'Anonymous',
                                rebirthCount: gameState.rebirthCount || 0,
                                gold: gameState.gold || 0,
                                ballCounts: gameState.ballCounts || {},
                                totalUpgrades: gameState.stats?.totalUpgrades || 0,
                                idleGoldPerSecond: gameState.idleGoldPerSecond || 0.5
                            });
                        }
                    });
                    leaders.sort((a, b) => b.rebirthCount - a.rebirthCount || b.gold - a.gold);
                    leaderboardList.innerHTML = '';
                    if (leaders.length === 0) {
                        console.log('No user data available');
                        leaderboardList.innerHTML = '<p>No leaderboard data available.</p>';
                        return;
                    }
                    const currentUser = auth.currentUser;
                    leaders.forEach((leader, index) => {
                        const entry = document.createElement('div');
                        entry.className = `leaderboard-card rank-${index + 1}${currentUser && leader.uid === currentUser.uid ? ' current-user' : ''}`;
                        entry.innerHTML = `
                    <span class="rank">${index + 1}</span>
                    <span class="info" style="font-weight: 600;">${leader.username} - Rebirths: ${leader.rebirthCount}, Gold: ${Math.floor(leader.gold)}</span>
                `;
                        entry.addEventListener('click', () => showUserDetails(leader));
                        leaderboardList.appendChild(entry);
                    });
                })
                .catch(error => {
                    console.error('Failed to fetch leaderboard:', error);
                    leaderboardList.innerHTML = '<p>Failed to load leaderboard.</p>';
                });
        }

        function showUserDetails(leader) {
            const overlay = document.createElement('div');
            overlay.className = 'user-details-overlay';
            overlay.innerHTML = `
        <div class="user-details-popup">
            <button class="close-btn"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-6"> <path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" /> </svg></button>
            <h3>${leader.username}</h3>
            <p>Rebirths: ${leader.rebirthCount}</p>
            <p>Gold: ${Math.floor(leader.gold)}</p>
            <p>Total Balls: ${
                (leader.ballCounts.sniper || 0) +
                (leader.ballCounts.big || 0) +
                (leader.ballCounts.explosion || 0) +
                (leader.ballCounts.multiplying || 0) +
                (leader.ballCounts.child || 0)
            }</p>
            <p>Total Upgrades: ${leader.totalUpgrades}</p>
            <p>Idle Gold Per Second: ${leader.idleGoldPerSecond.toFixed(2)}</p>
        </div>
    `;
            document.body.appendChild(overlay);
            overlay.querySelector('.close-btn').addEventListener('click', () => overlay.remove());
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) overlay.remove();
            });
        }

        // Show login popup when guest tries to save
        function showLoginPopupForSave() {
            const overlay = document.createElement('div');
            overlay.className = 'login-overlay';
            overlay.innerHTML = `
        <div class="login-popup">
            <h2>Login to Save</h2>
            <p>You are playing as a guest. Login or sign up to save your progress.</p>
            <input type="email" id="email" placeholder="Email">
            <input type="password" id="password" placeholder="Password">
            <div class="button-group">
                <button id="login-btn">Login</button>
                <button id="signup-btn">Sign Up</button>
                <button id="cancel-btn">Cancel</button>
            </div>
        </div>
    `;
            document.body.appendChild(overlay);
            saveToLocalStorage(); // Save progress to local storage
            const loginBtn = overlay.querySelector('#login-btn');
            const signupBtn = overlay.querySelector('#signup-btn');
            const cancelBtn = overlay.querySelector('#cancel-btn');
            loginBtn.addEventListener('click', () => {
                loginBtn.disabled = true;
                login();
            });
            signupBtn.addEventListener('click', () => {
                signupBtn.disabled = true;
                showSignUpPopup(overlay);
            });
            cancelBtn.addEventListener('click', () => {
                cancelBtn.disabled = true;
                overlay.remove();
            });
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    overlay.remove();
                }
            });
        }

        function saveToLocalStorage() {
            const gameState = {
                gold,
                level,
                ballCounts: {
                    sniper: balls.filter(b => b.type === 'sniper').length,
                    big: balls.filter(b => b.type === 'big').length,
                    explosion: balls.filter(b => b.type === 'explosion').length,
                    multiplying: balls.filter(b => b.type === 'multiplying').length,
                    child: balls.filter(b => b.type === 'child').length
                },
                autoBalls: autoBalls.length,
                ballPrices,
                autoBallPrice,
                idleGoldPerSecond,
                ballUpgrades,
                stats,
                username,
                rebirthCount,
                globalUpgrades: {
                    speedBoost: {
                        active: globalUpgrades.speedBoost.active,
                        activationTime: globalUpgrades.speedBoost.active ? Date.now() : null
                    },
                    goldBoost: {
                        active: globalUpgrades.goldBoost.active,
                        activationTime: globalUpgrades.goldBoost.active ? Date.now() : null
                    }
                }
            };
            localStorage.setItem('brickerGameState', JSON.stringify(gameState));
        }

        // Load game state
        function loadGameState(uid) {
            database.ref('users/' + uid + '/gameState').once('value')
                .then(snapshot => {
                    const data = snapshot.val();
                    if (data) {
                        gold = data.gold || 20;
                        level = data.level || 1;
                        ballPrices.sniper = data.ballPrices?.sniper || 50;
                        ballPrices.big = data.ballPrices?.big || 75;
                        ballPrices.explosion = data.ballPrices?.explosion || 100;
                        ballPrices.multiplying = data.ballPrices?.multiplying || 125;
                        autoBallPrice = data.autoBallPrice || 200;
                        idleGoldPerSecond = data.idleGoldPerSecond || 0.5;
                        rebirthCount = data.rebirthCount || 0;
                        ballUpgrades = data.ballUpgrades || {
                            sniper: {
                                level: 1,
                                speed: 4.5,
                                damage: 1
                            },
                            big: {
                                level: 1,
                                speed: 2.7,
                                damage: 1
                            },
                            explosion: {
                                level: 1,
                                speed: 2.7,
                                damage: 2
                            },
                            multiplying: {
                                level: 1,
                                speed: 2.7,
                                damage: 1
                            },
                            child: {
                                level: 1,
                                speed: 3.6,
                                damage: 1
                            }
                        };
                        stats = data.stats || {
                            totalPlayTime: 0,
                            totalBallsPurchased: 0,
                            totalUpgrades: 0,
                            startTime: Date.now()
                        };
                        username = data.username || '';
                        balls = [];
                        if (data.ballCounts) {
                            for (let i = 0; i < (data.ballCounts.sniper || 0); i++) {
                                balls.push(new Ball(canvas.width / 2, canvas.height / 2, 8, ballUpgrades.sniper.speed * (Math.random() * 2 - 1), ballUpgrades.sniper.speed * (Math.random() * 2 - 1), 'blue', 'sniper'));
                            }
                            for (let i = 0; i < (data.ballCounts.big || 0); i++) {
                                balls.push(new Ball(canvas.width / 2, canvas.height / 2, 12, ballUpgrades.big.speed * (Math.random() * 2 - 1), ballUpgrades.big.speed * (Math.random() * 2 - 1), 'green', 'big'));
                            }
                            for (let i = 0; i < (data.ballCounts.explosion || 0); i++) {
                                balls.push(new Ball(canvas.width / 2, canvas.height / 2, 8, ballUpgrades.explosion.speed * (Math.random() * 2 - 1), ballUpgrades.explosion.speed * (Math.random() * 2 - 1), 'orange', 'explosion'));
                            }
                            for (let i = 0; i < (data.ballCounts.multiplying || 0); i++) {
                                balls.push(new Ball(canvas.width / 2, canvas.height / 2, 8, ballUpgrades.multiplying.speed * (Math.random() * 2 - 1), ballUpgrades.multiplying.speed * (Math.random() * 2 - 1), 'purple', 'multiplying'));
                            }
                            for (let i = 0; i < (data.ballCounts.child || 0); i++) {
                                balls.push(new Ball(canvas.width / 2, canvas.height / 2, 4, ballUpgrades.child.speed * (Math.random() * 2 - 1), ballUpgrades.child.speed * (Math.random() * 2 - 1), 'purple', 'child'));
                            }
                        }
                        autoBalls = [];
                        for (let i = 0; i < (data.autoBalls || 0); i++) {
                            autoBalls.push(new AutoBall());
                        }
                        if (data.globalUpgrades) {
                            const now = Date.now();
                            if (data.globalUpgrades.speedBoost.active) {
                                const elapsed = now - data.globalUpgrades.speedBoost.activationTime;
                                if (elapsed < 60000) {
                                    globalUpgrades.speedBoost.active = true;
                                    setTimeout(() => {
                                        globalUpgrades.speedBoost.active = false;
                                        showToast('Speed boost expired!');
                                    }, 60000 - elapsed);
                                } else {
                                    globalUpgrades.speedBoost.active = false;
                                }
                            }
                            if (data.globalUpgrades.goldBoost.active) {
                                const elapsed = now - data.globalUpgrades.goldBoost.activationTime;
                                if (elapsed < 60000) {
                                    globalUpgrades.goldBoost.active = true;
                                    setTimeout(() => {
                                        globalUpgrades.goldBoost.active = false;
                                        showToast('Gold boost expired!');
                                    }, 60000 - elapsed);
                                } else {
                                    globalUpgrades.goldBoost.active = false;
                                }
                            }
                        }
                        updateUI();
                        spawnBricks();
                        startGame();
                    } else {
                        startGame();
                    }
                })
                .catch(error => {
                    showToast('Failed to load game: ' + error.message);
                    startGame();
                });
        }

        // Start the game
        function startGame() {
            spawnBricks();
            gameLoop();
            setInterval(saveGameState, 30000);
            setInterval(updatePlayTime, 1000);
            saveButton.addEventListener('click', saveGameState);
            document.getElementById('my-balls-btn').addEventListener('click', showMyBallsPopup);
            document.getElementById('settings-btn').addEventListener('click', showSettingsPopup);
            document.getElementById('weapons-btn').addEventListener('click', () => {
                if (gold >= weaponCost) {
                    gold -= weaponCost;
                    deployRandomWeapon();
                    updateUI();
                } else {
                    showToast('Not enough gold!');
                }
            });
        }

        // Update play time
        function updatePlayTime() {
            const currentTime = Date.now();
            stats.totalPlayTime += (currentTime - lastUpdateTime) / 1000;
            lastUpdateTime = currentTime;
        }

        // Generate passive gold
        function generatePassiveGold() {
            const multiplier = globalUpgrades.goldBoost.active ? 2 : 1;
            gold += idleGoldPerSecond * multiplier;
            updateUI();
        }
        setInterval(generatePassiveGold, 1000);

        // Simple spatial grid for collision optimization
        const gridSize = 100;

        function getGridCell(x, y) {
            return {
                col: Math.floor(x / gridSize),
                row: Math.floor(y / gridSize)
            };
        }

        function getNearbyBricks(ball) {
            const cell = getGridCell(ball.x, ball.y);
            const nearby = [];
            for (let row = cell.row - 1; row <= cell.row + 1; row++) {
                for (let col = cell.col - 1; col <= cell.col + 1; col++) {
                    bricks.forEach(brick => {
                        const brickCell = getGridCell(brick.x + brick.width / 2, brick.y + brick.height / 2);
                        if (brickCell.row === row && brickCell.col === col) {
                            nearby.push(brick);
                        }
                    });
                }
            }
            return nearby;
        }

        // Ball class
        class Ball {
            constructor(x, y, radius, dx, dy, color, type) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.dx = dx;
                this.dy = dy;
                this.color = color;
                this.type = type;
                this.powerUpUsed = false;
                this.hasBouncedWall = false;
            }

            move() {
                const speedMultiplier = globalUpgrades.speedBoost.active ? 2 : 1;
                this.x += this.dx * speedMultiplier;
                this.y += this.dy * speedMultiplier;

                if (this.x + this.radius > canvas.width) {
                    this.dx = -this.dx;
                    this.x = canvas.width - this.radius - 2;
                    if (this.type === 'sniper') this.redirectToClosestBrick();
                } else if (this.x - this.radius < 0) {
                    this.dx = -this.dx;
                    this.x = this.radius + 2;
                    if (this.type === 'sniper') this.redirectToClosestBrick();
                }

                if (this.y + this.radius > canvas.height) {
                    this.dy = -this.dy;
                    this.y = canvas.height - this.radius - 2;
                    if (this.type === 'sniper') this.redirectToClosestBrick();
                } else if (this.y - this.radius < 0) {
                    this.dy = -this.dy;
                    this.y = this.radius + 2;
                    if (this.type === 'sniper') this.redirectToClosestBrick();
                }

                bricks.forEach(brick => {
                    if (
                        this.x + this.radius > brick.x &&
                        this.x - this.radius < brick.x + brick.width &&
                        this.y + this.radius > brick.y &&
                        this.y - this.radius < brick.y + brick.height
                    ) {
                        const dx = this.x - (brick.x + brick.width / 2);
                        const dy = this.y - (brick.y + brick.height / 2);
                        if (Math.abs(dx) > Math.abs(dy)) {
                            this.dx = -this.dx;
                        } else {
                            this.dy = -this.dy;
                        }
                        this.handleBrickCollision(brick);
                    }
                });
            }

            redirectToClosestBrick() {
                if (this.type === 'sniper') {
                    const closestBrick = this.getClosestBrick();
                    if (closestBrick) {
                        const angle = Math.atan2(closestBrick.y + brickHeight / 2 - this.y, closestBrick.x + brickWidth / 2 - this.x);
                        this.dx = Math.cos(angle) * ballUpgrades.sniper.speed;
                        this.dy = Math.sin(angle) * ballUpgrades.sniper.speed;
                    }
                }
            }

            getClosestBrick() {
                let closestBrick = null;
                let closestDistance = Infinity;
                bricks.forEach(brick => {
                    const distance = Math.hypot(
                        this.x - (brick.x + brick.width / 2),
                        this.y - (brick.y + brick.height / 2)
                    );
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestBrick = brick;
                    }
                });
                return closestBrick;
            }

            handleBrickCollision(brick) {
                let damage = ballUpgrades[this.type].damage;
                if (this.type === 'explosion') {
                    brick.health -= damage;
                    const nearbyBricks = getNearbyBricks(this);
                    nearbyBricks.forEach(b => {
                        if (b !== brick) {
                            const distance = Math.hypot(b.x - brick.x, b.y - brick.y);
                            if (distance < 60) b.health -= Math.floor(damage / 2);
                        }
                    });
                } else {
                    brick.health -= damage;
                }
                if (brick.health <= 0) {
                    bricks = bricks.filter(b => b !== brick);
                    gold += 5;
                    if (powerUps.length < maxPowerUps) spawnPowerUp();
                    updateUI();
                }
                if (this.type === 'multiplying' && balls.length < maxBalls) {
                    balls.push(new Ball(
                        this.x,
                        this.y,
                        this.radius / 2,
                        ballUpgrades.child.speed * (Math.random() * 2 - 1),
                        ballUpgrades.child.speed * (Math.random() * 2 - 1),
                        this.color,
                        'child'
                    ));
                } else if (this.type === 'child') {
                    balls = balls.filter(ball => ball !== this);
                }
            }

            draw() {
                drawTrail(this);
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();
            }
        }

        // Brick class
        class Brick {
            constructor(x, y, health) {
                this.x = x;
                this.y = y;
                this.width = brickWidth;
                this.height = brickHeight;
                this.health = health + Math.floor(level / 2);
                this.hover = false;
            }

            isCursorHovering(mouseX, mouseY) {
                return (
                    mouseX > this.x &&
                    mouseX < this.x + this.width &&
                    mouseY > this.y &&
                    mouseY < this.y + this.height
                );
            }

            draw() {
                ctx.fillStyle = `rgba(255, 0, 0, ${this.health / (3 + level / 2)})`;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#fff';
                ctx.font = '18px Arial';
                ctx.fillText(Math.floor(this.health), this.x + this.width / 2 - 6, this.y + this.height / 2 + 4);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
            }
        }

        // BossBrick class
        class BossBrick extends Brick {
            constructor(x, y) {
                super(x, y, 10 + Math.floor(level / 2));
                this.width = 100;
                this.height = 40;
            }

            draw() {
                ctx.fillStyle = 'darkred';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#fff';
                ctx.font = '15px Arial';
                ctx.fillText(`Boss: ${Math.floor(this.health)}`, this.x + this.width / 4, this.y + this.height / 2);
            }
        }

        // PowerUp class
        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 20;
                this.height = 20;
                this.type = type;
                this.active = true;
                this.spawnTime = Date.now();
            }

            draw() {
                if (!this.active) return;
                const pulse = 1 + 0.1 * Math.sin(Date.now() / 200);
                const width = this.width * pulse;
                const height = this.height * pulse;
                ctx.fillStyle = {
                    gold: 'gold',
                    speed: 'cyan',
                    multiBall: 'magenta'
                } [this.type];
                ctx.fillRect(this.x - (width - this.width) / 2, this.y - (height - this.height) / 2, width, height);
            }

            collect() {
                if (Date.now() - this.spawnTime > 20000) {
                    this.active = false;
                    return;
                }
                balls.forEach(ball => {
                    if (ball.powerUpUsed) return;
                    if (
                        ball.x + ball.radius > this.x &&
                        ball.x - ball.radius < this.x + this.width &&
                        ball.y + ball.radius > this.y &&
                        ball.y - ball.radius < this.y + this.height
                    ) {
                        this.activatePowerUp(ball);
                    }
                });
            }

            activatePowerUp(ball) {
                ball.powerUpUsed = true;
                if (this.type === 'gold') gold += 50;
                if (this.type === 'speed') {
                    ball.dx *= 1.5;
                    ball.dy *= 1.5;
                }
                if (this.type === 'multiBall' && balls.length < maxBalls) {
                    balls.push(new Ball(ball.x, ball.y, ball.radius, -ball.dx, -ball.dy, ball.color, ball.type));
                }
                this.active = false;
                updateUI();
            }
        }

        // AutoBall class
        class AutoBall {
            constructor() {
                const maxCols = 6;
                const centerX = canvas.width / 2;
                const gridWidth = maxCols * brickWidth;
                const gridLeft = centerX - gridWidth / 2;
                this.x = gridLeft + Math.random() * gridWidth;
                this.y = canvas.height - 30;
                this.radius = 8;
                this.dy = -3.6;
                this.color = 'black';
            }

            move() {
                this.y += this.dy;
                if (this.y < 0) {
                    this.y = canvas.height - 30;
                    const maxCols = 6;
                    const centerX = canvas.width / 2;
                    const gridWidth = maxCols * brickWidth;
                    const gridLeft = centerX - gridWidth / 2;
                    this.x = gridLeft + Math.random() * gridWidth;
                }
                const nearbyBricks = getNearbyBricks(this);
                nearbyBricks.forEach(brick => {
                    if (
                        this.x > brick.x &&
                        this.x < brick.x + brick.width &&
                        this.y > brick.y &&
                        this.y < brick.y + brick.height
                    ) {
                        brick.health -= 1;
                        if (brick.health <= 0) {
                            bricks = bricks.filter(b => b !== brick);
                            gold += 5;
                            if (powerUps.length < maxPowerUps) spawnPowerUp();
                            updateUI();
                        }
                        this.y = canvas.height - 30;
                        const maxCols = 6;
                        const centerX = canvas.width / 2;
                        const gridWidth = maxCols * brickWidth;
                        const gridLeft = centerX - gridWidth / 2;
                        this.x = gridLeft + Math.random() * gridWidth;
                    }
                });
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();
            }
        }

        // Spawn power-up
        function spawnPowerUp() {
            if (Math.random() < 0.05 && powerUps.length < maxPowerUps) {
                let x, y, isOverlapping;
                do {
                    x = Math.random() * (canvas.width - 20);
                    y = Math.random() * (canvas.height - 20);
                    isOverlapping = bricks.some(brick => {
                        return (
                            x < brick.x + brick.width &&
                            x + 20 > brick.x &&
                            y < brick.y + brick.height &&
                            y + 20 > brick.y
                        );
                    });
                } while (isOverlapping);
                const type = ['gold', 'speed', 'multiBall'][Math.floor(Math.random() * 3)];
                powerUps.push(new PowerUp(x, y, type));
            }
        }

        // Spawn bricks
        function spawnBricks() {
            const maxRows = 11;
            const maxCols = 6;
            if (bricks.length < maxBricks) {
                const rows = Math.min(level, maxRows);
                const cols = Math.min(5, maxCols);
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const x = canvas.width / 2 - (cols * brickWidth) / 2 + col * brickWidth;
                        const y = canvas.height / 2 - (rows * brickHeight) / 2 + row * brickHeight;
                        if (!bricks.some(b => b.x === x && b.y === y)) {
                            bricks.push(new Brick(x, y, level));
                        }
                    }
                }
            } else {
                bricks.forEach(brick => {
                    brick.health += Math.floor(level / 2);
                });
            }
            if (level % 5 === 0 && !bricks.some(b => b instanceof BossBrick)) {
                bricks.push(new BossBrick(canvas.width / 2 - 50, canvas.height / 4));
            }
        }

        // Draw ball preview
        function drawBallPreview(canvasId, color, radius) {
            const previewCanvas = document.getElementById(canvasId);
            const previewCtx = previewCanvas.getContext('2d');
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            previewCtx.beginPath();
            previewCtx.arc(previewCanvas.width / 2, previewCanvas.height / 2, radius, 0, Math.PI * 2);
            previewCtx.fillStyle = color;
            previewCtx.fill();
            previewCtx.closePath();
        }

        // Update UI
        function updateUI() {
            goldDisplay.textContent = Math.floor(gold);
            levelDisplay.textContent = level;
            document.getElementById('sniperPrice').textContent = ballPrices.sniper;
            document.getElementById('bigPrice').textContent = ballPrices.big;
            document.getElementById('explosionPrice').textContent = ballPrices.explosion;
            document.getElementById('multiplyingPrice').textContent = ballPrices.multiplying;
            document.getElementById('autoPrice').textContent = autoBallPrice;
            drawBallPreview('sniper-preview', 'blue', 8);
            drawBallPreview('big-preview', 'green', 12);
            drawBallPreview('explosion-preview', 'orange', 8);
            drawBallPreview('multiplying-preview', 'purple', 8);
            drawBallPreview('auto-preview', 'black', 8);
        }

        // Buy ball
        function buyBall(type) {
            if (gold >= ballPrices[type] && balls.length < maxBalls) {
                gold -= ballPrices[type];
                ballPrices[type] = Math.floor(ballPrices[type] * 1.2);
                stats.totalBallsPurchased++;
                const radius = type === 'big' ? 12 : 8;
                const speed = ballUpgrades[type].speed;
                const dx = speed * (Math.random() > 0.5 ? 1 : -1);
                const dy = speed * (Math.random() > 0.5 ? 1 : -1);
                const color = {
                    sniper: 'blue',
                    big: 'green',
                    explosion: 'orange',
                    multiplying: 'purple'
                } [type];
                balls.push(new Ball(canvas.width / 2, canvas.height / 2, radius, dx, dy, color, type));
                updateUI();
            } else {
                showToast(balls.length >= maxBalls ? 'Max balls reached!' : 'Not enough gold!');
            }
        }

        // Buy auto ball
        function buyAutoBall() {
            if (gold >= autoBallPrice && autoBalls.length < 10) {
                gold -= autoBallPrice;
                stats.totalBallsPurchased++;
                autoBalls.push(new AutoBall());
                autoBallPrice = Math.floor(autoBallPrice * 1.3);
                updateUI();
            } else {
                showToast(autoBalls.length >= 10 ? 'Max auto-balls reached!' : 'Not enough gold!');
            }
        }

        // Upgrade ball
        function upgradeBall(type) {
            const cost = getUpgradeCost(type);
            if (gold >= cost) {
                gold -= cost;
                ballUpgrades[type].level++;
                ballUpgrades[type].speed += 0.5;
                ballUpgrades[type].damage += type === 'explosion' ? 0.5 : 0.2;
                stats.totalUpgrades++;
                balls.forEach(ball => {
                    if (ball.type === type) {
                        ball.dx = (ball.dx / Math.abs(ball.dx)) * ballUpgrades[type].speed;
                        ball.dy = (ball.dy / Math.abs(ball.dy)) * ballUpgrades[type].speed;
                    }
                });
                updateUI();
                showToast(`Upgraded ${type} ball to level ${ballUpgrades[type].level}!`);
            } else {
                showToast('Not enough gold!');
            }
        }

        // Apply global upgrade
        function applyGlobalUpgrade(type) {
            if (gold >= globalUpgrades[type].cost && !globalUpgrades[type].active) {
                gold -= globalUpgrades[type].cost;
                globalUpgrades[type].active = true;
                globalUpgrades[type].activationTime = Date.now();
                stats.totalUpgrades++;
                setTimeout(() => {
                    globalUpgrades[type].active = false;
                    showToast(`${type} boost expired!`);
                }, 60000);
                updateUI();
                showToast(`${type} boost activated for 1 minute!`);
            } else {
                showToast(globalUpgrades[type].active ? 'Upgrade already active!' : 'Not enough gold!');
            }
        }

        // Rebirth
        function rebirth() {
            if (level >= 100 && confirm('Are you sure you want to rebirth? You will lose all balls and gold but keep ball upgrades.')) {
                gold = 20;
                level = 1;
                balls = [];
                autoBalls = [];
                ballPrices.sniper = 50;
                ballPrices.big = 75;
                ballPrices.explosion = 100;
                ballPrices.multiplying = 125;
                autoBallPrice = 200;
                idleGoldPerSecond *= 1.2;
                globalUpgrades.speedBoost.active = false;
                globalUpgrades.goldBoost.active = false;
                bricks = [];
                powerUps = [];
                spawnBricks();
                updateUI();
                rebirthCount += 1;
                showToast('Rebirth successful! Starting from level 1 with retained ball upgrades.');
                saveGameState();
            } else {
                showToast(level < 100 ? 'You need to reach level 100 to rebirth!' : 'Rebirth cancelled.');
            }
        }

        // Show My Balls popup
        function showMyBallsPopup() {
            const overlay = document.createElement('div');
            overlay.className = 'login-overlay';
            const sniperCost = getUpgradeCost('sniper');
            const bigCost = getUpgradeCost('big');
            const explosionCost = getUpgradeCost('explosion');
            const multiplyingCost = getUpgradeCost('multiplying');
            const childCost = getUpgradeCost('child');
            overlay.innerHTML = `
        <div class="my-balls-popup">
            <h2>Upgrades</h2>
            <button class="close-btn"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-6"> <path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" /> </svg></button>
            <div class="nav-tabs">
                <button class="tab-btn active" data-tab="my-balls">My Balls</button>
                <button class="tab-btn" data-tab="upgrades">Boosts</button>
                <button class="tab-btn" data-tab="rebirth">Rebirth</button>
                <button class="tab-btn" data-tab="leaderboard">Leaderboard</button>
            </div>
            <div class="tab-content active" id="my-balls">
                <div class="ball-stats">
                    <div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <canvas id="sniper-stats-preview" width="40" height="40"></canvas>
                            <span><b>Sniper</b>: ${balls.filter(b => b.type === 'sniper').length} balls, Level: ${ballUpgrades.sniper.level}, Speed: ${ballUpgrades.sniper.speed.toFixed(1)}, Damage: ${ballUpgrades.sniper.damage.toFixed(1)}</span>
                        </div>
                        <button class="upgrade-btn" ${gold < sniperCost ? 'disabled' : ''} onclick="upgradeBall('sniper')">Upgrade<br>(${sniperCost} gold)</button>
                    </div>
                    <div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <canvas id="big-stats-preview" width="40" height="40"></canvas>
                            <span><b>Big</b>: ${balls.filter(b => b.type === 'big').length} balls, Level: ${ballUpgrades.big.level}, Speed: ${ballUpgrades.big.speed.toFixed(1)}, Damage: ${ballUpgrades.big.damage.toFixed(1)}</span>
                        </div>
                        <button class="upgrade-btn" ${gold < bigCost ? 'disabled' : ''} onclick="upgradeBall('big')">Upgrade<br>(${bigCost} gold)</button>
                    </div>
                    <div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <canvas id="explosion-stats-preview" width="40" height="40"></canvas>
                            <span><b>Bomb</b>: ${balls.filter(b => b.type === 'explosion').length} balls, Level: ${ballUpgrades.explosion.level}, Speed: ${ballUpgrades.explosion.speed.toFixed(1)}, Damage: ${ballUpgrades.explosion.damage.toFixed(1)}</span>
                        </div>
                        <button class="upgrade-btn" ${gold < explosionCost ? 'disabled' : ''} onclick="upgradeBall('explosion')">Upgrade<br>(${explosionCost} gold)</button>
                    </div>
                    <div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <canvas id="multiplying-stats-preview" width="40" height="40"></canvas>
                            <span><b>Clones</b>: ${balls.filter(b => b.type === 'multiplying').length} balls, Level: ${ballUpgrades.multiplying.level}, Speed: ${ballUpgrades.multiplying.speed.toFixed(1)}, Damage: ${ballUpgrades.multiplying.damage.toFixed(1)}</span>
                        </div>
                        <button class="upgrade-btn" ${gold < multiplyingCost ? 'disabled' : ''} onclick="upgradeBall('multiplying')">Upgrade<br>(${multiplyingCost} gold)</button>
                    </div>
                    <div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <canvas id="child-stats-preview" width="40" height="40"></canvas>
                            <span><b>Child</b>: ${balls.filter(b => b.type === 'child').length} balls, Level: ${ballUpgrades.child.level}, Speed: ${ballUpgrades.child.speed.toFixed(1)}, Damage: ${ballUpgrades.child.damage.toFixed(1)}</span>
                        </div>
                        <button class="upgrade-btn" ${gold < childCost ? 'disabled' : ''} onclick="upgradeBall('child')">Upgrade<br>(${childCost} gold)</button>
                    </div>
                    <div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <canvas id="auto-stats-preview" width="40" height="40"></canvas>
                            <span><b>Auto</b>: ${autoBalls.length} balls, Speed: 3.6, Damage: 1</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="tab-content" id="upgrades">
                <div class="upgrades-list">
                    <div style="display: flex; align-items: center; gap: 10px; background: linear-gradient(145deg, #f4eed6, #e9dcaf); padding: 12px; border-radius: 8px; border: 0 solid #333;">
                        <div style="width: 40px; height: 40px; background: cyan; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 20px;"></div>
                        <span style="flex: 1;">Speed Boost: Increase all ball speed by 2x for 1 minute</span>
                        <button class="upgrade-btn" ${globalUpgrades.speedBoost.active || gold < globalUpgrades.speedBoost.cost ? 'disabled' : ''} onclick="applyGlobalUpgrade('speedBoost')">${globalUpgrades.speedBoost.active ? 'Active' : 'Activate'}<br>(${globalUpgrades.speedBoost.cost} gold)</button>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px; background: linear-gradient(145deg, #f4eed6, #e9dcaf); padding: 12px; border-radius: 8px; border: 0 solid #333;">
                        <div style="width: 40px; height: 40px; background: gold; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 20px;"></div>
                        <span style="flex: 1;">Gold Boost: Increase gold production by 2x for 1 minute</span>
                        <button class="upgrade-btn" ${globalUpgrades.goldBoost.active || gold < globalUpgrades.goldBoost.cost ? 'disabled' : ''} onclick="applyGlobalUpgrade('goldBoost')">${globalUpgrades.goldBoost.active ? 'Active' : 'Activate'}<br>(${globalUpgrades.goldBoost.cost} gold)</button>
                    </div>
                </div>
            </div>
            <div class="tab-content" id="rebirth">
                <div class="rebirth-info">
                    <p>Rebirth at level 100 to start from level 1, losing all balls and gold but keeping ball upgrades.</p>
                    <p>Current Idle Gold Per Second: ${idleGoldPerSecond.toFixed(2)}</p>
                    <p>Each rebirth increases idle gold per second by 1.2 times.</p>
                    <button class="rebirth-btn" ${level < 100 ? 'disabled' : ''} onclick="rebirth()">Rebirth (Level ${level}/100)</button>
                </div>
            </div>
            <div class="tab-content" id="leaderboard">
                <div class="leaderboard-list">
                    <p>Loading leaderboard...</p>
                </div>
            </div>
        </div>
    `;
            document.body.appendChild(overlay);
            drawBallPreview('sniper-stats-preview', 'blue', 8);
            drawBallPreview('big-stats-preview', 'green', 12);
            drawBallPreview('explosion-stats-preview', 'orange', 8);
            drawBallPreview('multiplying-stats-preview', 'purple', 8);
            drawBallPreview('child-stats-preview', 'purple', 4);
            drawBallPreview('auto-stats-preview', 'black', 8);
            const tabs = overlay.querySelectorAll('.tab-btn');
            const contents = overlay.querySelectorAll('.tab-content');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    contents.forEach(c => c.classList.remove('active'));
                    tab.classList.add('active');
                    overlay.querySelector(`#${tab.dataset.tab}`).classList.add('active');
                    if (tab.dataset.tab === 'leaderboard') {
                        fetchLeaderboard();
                    }
                });
            });
            overlay.querySelector('.close-btn').addEventListener('click', () => overlay.remove());
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) overlay.remove();
            });
        }

        // Show settings popup
        function showSettingsPopup() {
            const user = auth.currentUser;
            const email = user ? user.email : 'Guest';
            const overlay = document.createElement('div');
            overlay.className = 'login-overlay';
            overlay.innerHTML = `
        <div class="settings-popup">
            <h2>Settings</h2>
            <button class="close-btn"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-6"> <path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" /> </svg></button>
            <div class="settings-info">
                <p>Email: ${email}</p>
                <p>Username: <span id="username-display">${username || 'Not set'}</span>
                    <span class="edit-icon" onclick="editUsername()"></span>
                </p>
                <div id="username-input" style="display: none;">
                    <input type="text" id="username-field" value="${username || ''}" placeholder="Enter username">
                    <button onclick="saveUsername()">Save</button>
                </div>
                <p>Total Play Time: ${(stats.totalPlayTime / 3600).toFixed(2)} hours</p>
                <p>Total Balls Purchased: ${stats.totalBallsPurchased}</p>
                <p>Total Upgrades Purchased: ${stats.totalUpgrades}</p>
                ${user ? `
                    <button onclick="auth.signOut().then(() => location.reload())">Log Out</button>
                    <button onclick="deleteAccount()">Delete Account</button>
                ` : ''}
            </div>
        </div>
    `;
            document.body.appendChild(overlay);
            overlay.querySelector('.close-btn').addEventListener('click', () => overlay.remove());
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) overlay.remove();
            });
        }

        // Edit username
        function editUsername() {
            document.getElementById('username-display').style.display = 'none';
            document.getElementById('username-input').style.display = 'block';
            document.querySelector('.edit-icon').style.display = 'none';
        }

        // Save username
        function saveUsername() {
            username = document.getElementById('username-field').value;
            document.getElementById('username-display').textContent = username || 'Not set';
            document.getElementById('username-display').style.display = 'inline';
            document.getElementById('username-input').style.display = 'none';
            document.querySelector('.edit-icon').style.display = 'inline';
            saveGameState();
        }

        // Delete account
        function deleteAccount() {
            const user = auth.currentUser;
            if (user && confirm('Are you sure you want to delete your account? This action cannot be undone.')) {
                database.ref('users/' + user.uid).remove()
                    .then(() => {
                        user.delete()
                            .then(() => {
                                showToast('Account deleted successfully.');
                                location.reload();
                            })
                            .catch(error => showToast('Failed to delete account: ' + error.message));
                    })
                    .catch(error => showToast('Failed to delete game data: ' + error.message));
            }
        }

        const weaponCost = 1000;

        // Deploy random weapon
        function deployRandomWeapon() {
            const weapons = ['nuke', 'airstrike', 'gravity', 'laser', 'blackhole'];
            const randomWeapon = weapons[Math.floor(Math.random() * weapons.length)];
            switch (randomWeapon) {
                case 'nuke':
                    deployNuke();
                    break;
                case 'airstrike':
                    deployAirstrike();
                    break;
                case 'gravity':
                    manipulateGravity();
                    break;
                case 'laser':
                    deployLaser();
                    break;
                case 'blackhole':
                    createBlackhole();
                    break;
            }
        }

        // Deploy nuke
        function deployNuke() {
            showToast('Nuke deployed! All bricks destroyed!');
            setTimeout(() => {
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height / 2, 200, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.fill();
                ctx.closePath();
                bricks.forEach(brick => {
                    brick.health = 0;
                    bricks = bricks.filter(b => b !== brick);
                    gold += 5;
                    if (powerUps.length < maxPowerUps) spawnPowerUp();
                });
                updateUI();
            }, 0);
        }

        // Deploy airstrike
        function deployAirstrike() {
            showToast('Airstrike deployed! 3 random bricks destroyed!');
            ctx.fillStyle = 'rgba(0, 0, 255, 0.3)';
            ctx.fillRect(canvas.width / 2 - 150, 0, 300, 50);
            for (let i = 0; i < 3; i++) {
                const randomBrick = bricks[Math.floor(Math.random() * bricks.length)];
                if (randomBrick) {
                    randomBrick.health = 0;
                    bricks = bricks.filter(b => b !== randomBrick);
                    gold += 5;
                    if (powerUps.length < maxPowerUps) spawnPowerUp();
                    updateUI();
                }
            }
        }

        // Manipulate gravity
        function manipulateGravity() {
            showToast('Gravity increased! Balls fall faster for 10 seconds!');
            const originalDy = balls.map(ball => ball.dy);
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, 150, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
            ctx.fill();
            ctx.closePath();
            balls.forEach(ball => {
                ball.dy *= 1.5;
            });
            setTimeout(() => {
                balls.forEach((ball, index) => {
                    ball.dy = originalDy[index];
                });
            }, 10000);
        }

        // Deploy laser
        function deployLaser() {
            showToast('Laser deployed! Destroys bricks for 5 seconds!');
            const laser = {
                x: canvas.width / 2,
                y: 0,
                width: 5,
                height: canvas.height,
                color: 'red'
            };
            const laserInterval = setInterval(() => {
                ctx.fillStyle = laser.color;
                ctx.fillRect(laser.x, laser.y, laser.width, laser.height);
                const nearbyBricks = getNearbyBricks({
                    x: laser.x + laser.width / 2,
                    y: laser.height / 2
                });
                nearbyBricks.forEach(brick => {
                    if (laser.x + laser.width > brick.x && laser.x < brick.x + brick.width) {
                        brick.health = 0;
                        bricks = bricks.filter(b => b !== brick);
                        gold += 5;
                        if (powerUps.length < maxPowerUps) spawnPowerUp();
                        updateUI();
                    }
                });
            }, 50);
            setTimeout(() => clearInterval(laserInterval), 5000);
        }

        // Create blackhole
        function createBlackhole() {
            showToast('Blackhole created! Pulls balls and bricks for 5 seconds!');
            const blackhole = {
                x: canvas.width / 2,
                y: canvas.height / 2,
                radius: 50
            };
            const blackholeInterval = setInterval(() => {
                ctx.beginPath();
                ctx.arc(blackhole.x, blackhole.y, blackhole.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 1)';
                ctx.fill();
                ctx.closePath();
                balls.forEach(ball => {
                    const angle = Math.atan2(blackhole.y - ball.y, blackhole.x - ball.x);
                    ball.x += Math.cos(angle) * 2;
                    ball.y += Math.sin(angle) * 2;
                });
                bricks.forEach((brick, index) => {
                    const angle = Math.atan2(blackhole.y - brick.y, blackhole.x - brick.x);
                    brick.x += Math.cos(angle) * 0.5;
                    brick.y += Math.sin(angle) * 0.5;
                    const distance = Math.sqrt(Math.pow(blackhole.x - brick.x, 2) + Math.pow(blackhole.y - brick.y, 2));
                    if (distance < blackhole.radius) {
                        brick.health = 0;
                        bricks = bricks.filter(b => b !== brick);
                        gold += 5;
                        if (powerUps.length < maxPowerUps) spawnPowerUp();
                        updateUI();
                    }
                });
            }, 30);
            setTimeout(() => clearInterval(blackholeInterval), 5000);
        }

        // Draw trail
        function drawTrail(ball) {
            const speed = Math.sqrt(ball.dx ** 2 + ball.dy ** 2);
            const trailLength = Math.min(5, Math.max(3, speed * 2));
            if (!ball.trail) ball.trail = [];
            ball.trail.push({
                x: ball.x,
                y: ball.y
            });
            if (ball.trail.length > trailLength) ball.trail.shift();
            ball.trail.forEach((position, index) => {
                const alpha = index / ball.trail.length;
                ctx.beginPath();
                ctx.arc(position.x, position.y, ball.radius * 1.2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${0.2 * alpha})`;
                ctx.fill();
                ctx.closePath();
            });
        }

        // Next level
        function nextLevel() {
            if (bricks.length === 0) {
                level++;
                spawnBricks();
                updateUI();
            }
        }

        // Game loop
        function gameLoop() {
            let lastTime = performance.now();

            function loop(timestamp) {
                const deltaTime = (timestamp - lastTime) / 1000;
                lastTime = timestamp;

                if (document.hidden) {
                    generatePassiveGold();
                    updatePlayTime();
                } else {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    balls.forEach(ball => {
                        drawTrail(ball);
                        ball.move();
                        ball.draw();
                    });
                    effects.forEach(effect => {
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, 5, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 255, 0, ${effect.timer / 10})`;
                        ctx.fill();
                        ctx.closePath();
                        effect.timer--;
                    });
                    effects = effects.filter(effect => effect.timer > 0);
                    powerUps = powerUps.filter(p => p.active);
                    powerUps.forEach(powerUp => {
                        if (powerUp.active) {
                            powerUp.draw();
                            powerUp.collect();
                        }
                    });
                    autoBalls.forEach(autoBall => {
                        autoBall.move();
                        autoBall.draw();
                    });
                    bricks.forEach(brick => brick.draw());
                    nextLevel();
                }
                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);
        }

        // Canvas click event
        canvas.addEventListener('click', (e) => {
            const mouseX = e.clientX - canvas.offsetLeft;
            const mouseY = e.clientY - canvas.offsetTop;
            let isHovering = false;
            bricks.forEach(brick => {
                if (brick.isCursorHovering(mouseX, mouseY)) {
                    brick.health -= 1;
                    if (brick.health <= 0) {
                        bricks = bricks.filter(b => b !== brick);
                        gold += 5;
                        if (powerUps.length < maxPowerUps) spawnPowerUp();
                        updateUI();
                    }
                    isHovering = true;
                }
            });
            canvas.style.cursor = isHovering ? 'pointer' : 'default';
        });
    </script>
</body>

</html>
